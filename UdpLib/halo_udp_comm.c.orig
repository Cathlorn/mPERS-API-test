#include <unistd.h>
#include <string.h>
#include <stdio.h>
#include <assert.h>

#include "myHaloUdp.h"
#include "halo_udp_comm.h"
#include "udp_lib.h"
#include "tx_buffer.h"
#include "../HaloMsgHelperFunctions.h"
#include "halo_udp_tx_mgmt.h"
#include "crc16.h"

typedef struct
{
    UdpCommStruct haloUdpCommStruct;
    HaloUdpTxMgmt txMgmt;
    int tickCount;
    uint16 txSeqNum;
    HaloUdpUserData *userData;
}
HaloUdpCommData;

typedef struct
{
    MyHaloUdpHeader header;
    uint16 crc;
}
HaloUdpAckPkt;

//Stores the data used to handle the halo UDP communications stack
static HaloUdpCommData haloUdpCommData;

//Function Prototypes
void udp_recv_handler(void *data);
void halo_msg_rexmit(void);

//Handler for successfully sent msgs
void halo_msg_tx_sent(uint16 txSeqNum);

//Handler for failed transmitted msgs
void halo_msg_tx_dropped(uint16 txSeqNum);

void halo_msg_init(uint8 actAsServer, HaloUdpUserData *userData)
{
    UdpCommStruct *commStruct = NULL;

    commStruct = &haloUdpCommData.haloUdpCommStruct;

    //UDP Init
    //Sets up port (localhost:53778)
    strcpy(commStruct->hostname, "localhost");
    strcpy(commStruct->port, "53778");

    //Enables Debugging
    commStruct->debug = 1;

    commStruct->actAsServer = actAsServer;

    //Assigns event handlers
    commStruct->dataSent = NULL;
    commStruct->dataReceived = udp_recv_handler;

    udp_init(commStruct);

    //Tx Mgmt Init
    haloUdpCommData.txMgmt.pendingTx       = 0;
    haloUdpCommData.txMgmt.pendingTxData   = NULL;
    haloUdpCommData.txMgmt.pendingTxLen    = 0;
    haloUdpCommData.txMgmt.pendingTxSeqNum = 0;
    haloUdpCommData.txMgmt.txRetryCount    = 0;

    //Tick Mgmt Init
    haloUdpCommData.tickCount = 0;

    haloUdpCommData.txSeqNum = 0;

    haloUdpCommData.userData = userData;
}

int halo_msg_send(const HaloMessage *msg)
{
    MyHaloUdpHeader header;
    UdpCommStruct *commStruct = NULL;
    HaloUdpTxMgmt *txMgmt = NULL;
    int msgLen;
    int payloadLen;
    uint8 *data;
    int dataLen;
    uint16 pktCrc;

    commStruct = &haloUdpCommData.haloUdpCommStruct;
    txMgmt     = &haloUdpCommData.txMgmt;
    payloadLen = getMsgLength(msg);

    msgLen = payloadLen;
    //Update the msg length
    msgLen += sizeof(MyHaloUdpHeader); //header: udp data
    msgLen += sizeof(uint16);  //tail: crc

    //Allocate a tx buffer
    if (getBuffer(msgLen, (void **) &data, &dataLen) != SUCCESS)
    {
        printf("Unable to allocate buffer!\n");
        assert(0);
    }

    //Fill header with all zeroes
    memset(&header, 0, sizeof(header));
    header.status |= DATA_AVAILABLE;

    header.seqNum = haloUdpCommData.txSeqNum;

    //Copy data into the tx buffer
    memcpy(data, &header, sizeof(header));
    memcpy(&data[sizeof(header)], msg, payloadLen);

    pktCrc = hdlcFcs16(hdlc_init_fcs16, data, msgLen - 2);

    //Copy CRC
    memcpy(&data[msgLen - 2], &pktCrc, sizeof(pktCrc));

    //Data transmission happens from here
    if (udp_send(commStruct, data, msgLen) > 0)
    {
        //Advance the sequence number
        haloUdpCommData.txSeqNum++;
    }

    if (enqueue_tx_packet(txMgmt, data, msgLen, header.seqNum) == SUCCESS)
    {
        //Do Nothing
    }
    else
    {
        printf("Unable to place data into the tx queue!\n");
        assert(0);
    }

    return 0;
}

//Manages retransmitting a pending msg
void halo_msg_rexmit(void)
{
    UdpCommStruct *commStruct = NULL;
    HaloUdpTxMgmt *txMgmt = NULL;
    uint8 *data;
    int dataLen;
    uint16 seqNum;

    commStruct = &haloUdpCommData.haloUdpCommStruct;
    txMgmt     = &haloUdpCommData.txMgmt;

    if (peek_tx_packet(txMgmt, &data, &dataLen, &seqNum) == SUCCESS)
    {
        //Data transmission happens from here
        udp_send(commStruct, data, dataLen);
    }
}

//Handler for successfully sent msgs
void halo_msg_tx_sent(uint16 txSeqNum)
{
    HaloUdpTxMgmt *txMgmt = NULL;
    uint8 *data;
    int dataLen;
    uint16 seqNum;

    txMgmt     = &haloUdpCommData.txMgmt;

    if (peek_tx_packet(txMgmt, &data, &dataLen, &seqNum) == SUCCESS)
    {

        //TO DO: Redo how this drops
        dequeue_tx_packet(txMgmt, txSeqNum); //Add function to unconditionally drop

        //Notify to user that msg has been sent
        if (haloUdpCommData.userData)
            haloUdpCommData.userData->msg_tx_sent(&data[sizeof(MyHaloUdpHeader)]);

        //Return the buffer
        freeBuffer(data);
    }
}

//Handler for failed transmitted msgs
void halo_msg_tx_dropped(uint16 txSeqNum)
{
    HaloUdpTxMgmt *txMgmt = NULL;
    uint8 *data;
    int dataLen;
    uint16 seqNum;

    txMgmt     = &haloUdpCommData.txMgmt;

    if (peek_tx_packet(txMgmt, &data, &dataLen, &seqNum) == SUCCESS)
    {

        //TO DO: Redo how this drops
        dequeue_tx_packet(txMgmt, txSeqNum); //Add function to unconditionally drop

        //Notify to user that msg has been dropped
        if (haloUdpCommData.userData)
            haloUdpCommData.userData->msg_tx_dropped(&data[sizeof(MyHaloUdpHeader)]);

        //Return the buffer
        freeBuffer(data);
        printf("Dropping msg! Retransmit limit exceeded!\n");
    }
}

void udp_recv_handler(void *data)
{
    HaloUdpTxMgmt *txMgmt = NULL;
    UdpRecvArgs args = *(UdpRecvArgs *) data;
    MyHaloUdpHeader *header = (MyHaloUdpHeader *) args.data;
    int i;
    uint8 *payloadPtr;
    int payloadLength;
    uint16 pktCrc;  //CRC Includes the header and the payload to make sure everything's correct.
    uint16 calculatedCrc;
    uint8 processPkt = 1;

    payloadLength = args.length;
    payloadLength -= sizeof(MyHaloUdpHeader); //Remove header size
    payloadLength -= sizeof(pktCrc);          //Remove CRC size
    payloadPtr = &args.data[sizeof(MyHaloUdpHeader)];

    pktCrc = ((uint16) (payloadPtr[payloadLength] & 0xff)) | ((uint16) payloadPtr[payloadLength + 1] << 8);

    //Calculate CRC
    calculatedCrc = hdlcFcs16(hdlc_init_fcs16, args.data, args.length - 2);

    if (payloadLength < 0)
    {
        printf("Runt: Negative payload calculated.\n");
        processPkt = 0;
    }

    if (pktCrc != calculatedCrc)
    {
        printf("CRC Error: Pkt contains incorrect CRC.\n");
        processPkt = 0;
    }

    if (processPkt) //Validates the data
    {

        txMgmt     = &haloUdpCommData.txMgmt;

        //Handles Acknowledgements
        if ((header->status & MSG_RECEIVED_ACK) == MSG_RECEIVED_ACK)
        {
            //Ack Received
            halo_msg_tx_sent(header->seqNum);
        }

        //Handles a New Data Msg
        if ((header->status & DATA_AVAILABLE) == DATA_AVAILABLE)
        {
            int i;

            //Send notification of receipt of ack to server
            HaloUdpAckPkt ackPkt;
            memset(&ackPkt.header, 0, sizeof(ackPkt.header));
            ackPkt.header.status    |= MSG_RECEIVED_ACK;
            ackPkt.header.ackSeqNum  = header->seqNum;
            ackPkt.header.seqNum     = haloUdpCommData.txSeqNum;
            ackPkt.crc = hdlcFcs16(hdlc_init_fcs16, &ackPkt, sizeof(ackPkt) - sizeof(uint16));

            if (udp_send(args.commStruct, (uint8 *) &ackPkt, sizeof(ackPkt)) > 0)
            {
                //Advance the sequence number
                haloUdpCommData.txSeqNum++;
            }

            if ((haloUdpCommData.userData)&&(haloUdpCommData.userData->debug))
            {
                printf("Binary Structure printout: \n");

                for (i=0;i< args.length; i++)
                {
                    printf("%02x ", args.data[i]);
                    if ((i % 8) == 7)
                        printf("\n");
                }
                printf("\n");
            }

            //Notify that new data has been received
            if (haloUdpCommData.userData)
                haloUdpCommData.userData->msg_rx_received(payloadPtr);
        }
    }
}

void halo_msg_tick(void)
{
    UdpCommStruct *commStruct = NULL;
    HaloUdpTxMgmt *txMgmt = NULL;

    commStruct = &haloUdpCommData.haloUdpCommStruct;
    txMgmt     = &haloUdpCommData.txMgmt;

    udp_tick(commStruct);

    //Retransmission
    if ((haloUdpCommData.tickCount % TICKS_PER_REXMIT) == (TICKS_PER_REXMIT - 1))
    {
        if (pending_tx_packet(txMgmt))
        {
            //Rexmit
            if ((txMgmt->txRetryCount < MAX_REXMIT)&&(MAX_REXMIT > 0))
            {
                halo_msg_rexmit();
                txMgmt->txRetryCount++;
            }
            else
            {
                //Handle retransmission reached

                halo_msg_tx_dropped(txMgmt->pendingTxSeqNum);
                txMgmt->txRetryCount = 0;
            }
        }
    }

    haloUdpCommData.tickCount++;
}
